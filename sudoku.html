<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sudoku style - Babylon.js</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/cannon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            font-family: 'Arial', sans-serif;
        }
        
        /* Notifications optimis√©es */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 20px 30px;
            border-radius: 15px;
            border: 2px solid #FFD700;
            font-size: 18px;
            z-index: 10000;
            animation: slideIn 0.3s ease-out, slideOut 0.3s ease-out 2.7s;
            pointer-events: none;
            box-shadow: 0 4px 20px rgba(255, 215, 0, 0.5);
        }
        
        @keyframes slideIn {
            from { transform: translateX(400px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        @keyframes slideOut {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(400px); opacity: 0; }
        }

        #renderCanvas {
            width: 100%;
            height: 100vh;
            touch-action: none;
            display: none;
        }

        /* Interface de menu */
        #menuInterface {
            position: fixed;
            width: 100%;
            height: 100vh;
            background: #1a1a2e;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        /* Canvas de fond pour le menu */
        #menuCanvas {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            z-index: -1;
            opacity: 0.3;
        }

        #menuInterface h1 {
            color: white;
            font-size: 72px;
            font-weight: bold;
            text-shadow: 0 8px 16px rgba(0,0,0,0.3);
            margin-bottom: 60px;
            letter-spacing: 4px;
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from {
                text-shadow: 0 8px 16px rgba(0,0,0,0.3), 0 0 20px rgba(255,255,255,0.3);
            }
            to {
                text-shadow: 0 8px 16px rgba(0,0,0,0.3), 0 0 40px rgba(255,255,255,0.6);
            }
        }

        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 25px;
        }

        .menu-button {
            padding: 20px 80px;
            font-size: 28px;
            font-weight: bold;
            color: white;
            background: rgba(255, 255, 255, 0.2);
            border: 3px solid white;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.3);
        }

        .menu-button:hover {
            background: white;
            color: #667eea;
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 12px 30px rgba(0,0,0,0.4);
        }

        .menu-button:active {
            transform: translateY(-2px) scale(1.02);
        }

        /* Interface de cr√©dits */
        #creditsInterface {
            position: fixed;
            width: 100%;
            height: 100vh;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1001;
            padding: 40px;
        }

        #creditsInterface h2 {
            color: white;
            font-size: 48px;
            margin-bottom: 40px;
            text-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .credits-content {
            background: rgba(255, 255, 255, 0.1);
            padding: 40px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255,255,255,0.3);
            max-width: 600px;
            margin-bottom: 30px;
        }

        .credits-content p {
            color: white;
            font-size: 20px;
            line-height: 1.8;
            margin: 15px 0;
        }

        .credits-content strong {
            color: #ffd700;
        }

        .credits-content a {
            color: #ffd700;
            text-decoration: none;
            transition: all 0.3s ease;
        }

        .credits-content a:hover {
            color: white;
            text-decoration: underline;
        }

        #backButton {
            padding: 15px 60px;
            font-size: 22px;
            font-weight: bold;
            color: white;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid white;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }
        
        /* Interface des contr√¥les */
        #controlsInterface {
            position: fixed;
            width: 100%;
            height: 100vh;
            background: linear-gradient(135deg, #2d1b69 0%, #6a3093 100%);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1001;
            padding: 40px;
        }
        
        #controlsInterface h2 {
            color: white;
            font-size: 48px;
            margin-bottom: 40px;
            text-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        .controls-content {
            background: rgba(255, 255, 255, 0.1);
            padding: 40px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255,255,255,0.3);
            max-width: 90%;
            max-height: 70vh;
            overflow-y: auto;
            margin-bottom: 30px;
            display: flex;
            flex-wrap: wrap;
            gap: 30px;
            justify-content: center;
        }
        
        /* Scrollbar personnalis√©e pour les contr√¥les */
        .controls-content::-webkit-scrollbar {
            width: 12px;
        }
        
        .controls-content::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }
        
        .controls-content::-webkit-scrollbar-thumb {
            background: #FFD700;
            border-radius: 10px;
            border: 2px solid rgba(255, 255, 255, 0.1);
        }
        
        .controls-content::-webkit-scrollbar-thumb:hover {
            background: #FFA500;
        }
        
        .controls-content p {
            color: white;
            font-size: 18px;
            line-height: 1.8;
            margin: 10px 0;
        }
        
        .controls-content strong {
            color: #ffd700;
            min-width: 150px;
            display: inline-block;
        }
        
        .controls-section {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 15px;
            border: 1px solid rgba(255,255,255,0.2);
            flex: 1 1 300px;
            min-width: 280px;
            max-width: 400px;
        }
        
        .controls-section h3 {
            color: #ffd700;
            font-size: 24px;
            margin-bottom: 15px;
        }

        #backButton:hover {
            background: white;
            color: #2a5298;
            transform: scale(1.05);
        }
        
        /* Interface du magasin */
        #shopInterface {
            position: fixed;
            width: 100%;
            height: 100vh;
            background: linear-gradient(135deg, #1a472a 0%, #2d7a4d 100%);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1001;
            padding: 40px;
        }
        
        #shopInterface h2 {
            color: #FFD700;
            font-size: 48px;
            margin-bottom: 40px;
            text-shadow: 0 4px 8px rgba(0,0,0,0.5);
        }
        
        .shop-content {
            background: rgba(0, 0, 0, 0.3);
            padding: 40px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255,215,0,0.5);
            max-width: 900px;
            max-height: 70vh;
            overflow-y: auto;
            margin-bottom: 30px;
        }
        
        .shop-content::-webkit-scrollbar {
            width: 10px;
        }
        
        .shop-content::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
        }
        
        .shop-content::-webkit-scrollbar-thumb {
            background: #FFD700;
            border-radius: 10px;
        }
        
        .shop-content::-webkit-scrollbar-thumb:hover {
            background: #FFA500;
        }
        
        .shop-items {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-top: 20px;
        }
        
        .shop-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid rgba(255,215,0,0.3);
            text-align: center;
            transition: all 0.3s ease;
        }
        
        .shop-item:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: #FFD700;
            transform: translateY(-5px);
        }
        
        .shop-item h3 {
            color: #FFD700;
            font-size: 24px;
            margin-bottom: 10px;
        }
        
        .shop-item p {
            color: white;
            font-size: 16px;
            margin: 10px 0;
        }
        
        .shop-item .price {
            color: #FFD700;
            font-size: 22px;
            font-weight: bold;
            margin: 15px 0;
        }
        
        .shop-item button {
            padding: 10px 30px;
            font-size: 18px;
            color: white;
            background: #2d7a4d;
            border: 2px solid #FFD700;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .shop-item button:hover {
            background: #3a9c63;
            transform: scale(1.05);
        }
        
        .shop-item button:disabled {
            background: #555;
            border-color: #888;
            cursor: not-allowed;
            opacity: 0.5;
        }

        /* Affiche Expaceo */
        .expaceo-poster {
            position: absolute;
            bottom: 30px;
            right: 30px;
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            display: flex;
            align-items: center;
            gap: 15px;
            transition: all 0.3s ease;
            background-image: url('https://expaceo.com/wp-content/uploads/2023/05/logo-expaceo.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            padding: 30px 50px;
        }

        .expaceo-poster:hover {
            transform: scale(1.05);
            box-shadow: 0 15px 40px rgba(0,0,0,0.4);
        }

        .expaceo-poster .text {
            font-size: 24px;
            font-weight: bold;
            color: #000000;
            letter-spacing: 1px;
            position: relative;
            z-index: 1;
        }

        .expaceo-poster .text .red {
            color: #ff0000;
        }
        
        /* Compteur de pi√®ces dans le menu */
        .menu-coins {
            position: absolute;
            top: 20px;
            right: 30px;
            color: #FFD700;
            font-size: 28px;
            font-weight: bold;
            text-shadow: 0 4px 8px rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(0, 0, 0, 0.3);
            padding: 15px 25px;
            border-radius: 50px;
            border: 2px solid #FFD700;
        }

        /* Canvas cach√© au d√©part */
        #renderCanvas.active {
            display: block;
        }
        
        /* Grille Sudoku en fond du menu */
        .sudoku-background {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(1.5);
            display: grid;
            grid-template-columns: repeat(9, 80px);
            grid-template-rows: repeat(9, 80px);
            gap: 0;
            opacity: 0.25;
            font-size: 42px;
            font-weight: bold;
            color: white;
            z-index: 0;
            pointer-events: none;
        }
        
        .sudoku-background .cell {
            width: 80px;
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid rgba(255,255,255,0.4);
        }
        
        .sudoku-background .cell:nth-child(3n) {
            border-right: 4px solid rgba(255,255,255,0.6);
        }
        
        .sudoku-background .cell:nth-child(n+19):nth-child(-n+27),
        .sudoku-background .cell:nth-child(n+46):nth-child(-n+54) {
            border-bottom: 4px solid rgba(255,255,255,0.6);
        }
    </style>
</head>
<body>
    <!-- Canvas de fond pour le menu -->
    <canvas id="menuCanvas"></canvas>
    
    <!-- Interface de menu principal -->
    <div id="menuInterface">
        <!-- Grille Sudoku en fond -->
        <div class="sudoku-background">
            <div class="cell">5</div><div class="cell">3</div><div class="cell"></div><div class="cell"></div><div class="cell">7</div><div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
            <div class="cell">6</div><div class="cell"></div><div class="cell"></div><div class="cell">1</div><div class="cell">9</div><div class="cell">5</div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
            <div class="cell"></div><div class="cell">9</div><div class="cell">8</div><div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell">6</div><div class="cell"></div>
            <div class="cell">8</div><div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell">6</div><div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell">3</div>
            <div class="cell">4</div><div class="cell"></div><div class="cell"></div><div class="cell">8</div><div class="cell"></div><div class="cell">3</div><div class="cell"></div><div class="cell"></div><div class="cell">1</div>
            <div class="cell">7</div><div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell">2</div><div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell">6</div>
            <div class="cell"></div><div class="cell">6</div><div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell">2</div><div class="cell">8</div><div class="cell"></div>
            <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell">4</div><div class="cell">1</div><div class="cell">9</div><div class="cell"></div><div class="cell"></div><div class="cell">5</div>
            <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell">8</div><div class="cell"></div><div class="cell"></div><div class="cell">7</div><div class="cell">9</div>
        </div>
        <!-- Compteur de pi√®ces -->
        <div class="menu-coins">
            <span>ü™ô</span>
            <span id="menuCoinsCount">0</span>
        </div>
        <h1>sudoku style</h1>
        <div class="menu-buttons">
            <button class="menu-button" id="playButton">Play</button>
            <button class="menu-button" id="progressButton">Progression</button>
            <button class="menu-button" id="shopButton">Magasin</button>
            <button class="menu-button" id="controlsButton">Contr√¥les</button>
            <button class="menu-button" id="creditsButton">Cr√©dits</button>
        </div>
        <!-- Affiche Expaceo -->
        <div class="expaceo-poster">
            <div class="text">E<span class="red">X</span>PACEO</div>
        </div>
    </div>

    <!-- Interface de cr√©dits -->
    <div id="creditsInterface">
        <h2>CR√âDITS</h2>
        <div class="credits-content">
            <p><strong>D√©veloppeur :</strong> Expaceo Stagiaire :)</p>
            <p><strong>Entreprise :</strong> <a href="https://expaceo.com" target="_blank">Expaceo</a></p>
            <p><strong>Moteur 3D :</strong> Babylon.js</p>
            <p><strong>Physique :</strong> Cannon.js</p>
            <p><strong>Concept :</strong> Sudoku qui est immersif</p>
            <p><strong>Version :</strong> 0.1</p>
        </div>
        <button id="backButton">Retour</button>
    </div>
    
    <!-- Interface de progression -->
    <div id="progressInterface" style="position: fixed; width: 100%; height: 100vh; background: linear-gradient(135deg, #2d3561 0%, #4a5899 100%); display: none; flex-direction: column; align-items: center; justify-content: flex-start; z-index: 1001; padding: 40px; overflow-y: auto;">
        <h2 style="color: #FFD700; font-size: 48px; margin-bottom: 20px; text-shadow: 0 4px 8px rgba(0,0,0,0.5);">PROGRESSION</h2>
        <div style="background: rgba(0, 0, 0, 0.3); padding: 30px; border-radius: 20px; backdrop-filter: blur(10px); border: 2px solid rgba(255,215,0,0.5); max-width: 900px; width: 100%; margin-bottom: 30px;">
            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 30px; margin-top: 20px;">
                <!-- Niveau Facile -->
                <div style="background: rgba(0, 255, 0, 0.1); padding: 25px; border-radius: 15px; border: 2px solid rgba(0, 255, 0, 0.3); text-align: center;">
                    <h3 style="color: #00FF00; font-size: 28px; margin-bottom: 15px;">üë∂ FACILE</h3>
                    <p style="color: white; font-size: 18px; margin: 10px 0;">Niveaux compl√©t√©s:</p>
                    <p id="easyProgress" style="color: #FFD700; font-size: 32px; font-weight: bold;">0 / 334</p>
                    <button onclick="selectDifficulty('easy')" style="padding: 12px 30px; font-size: 18px; color: white; background: #00AA00; border: 2px solid #00FF00; border-radius: 25px; cursor: pointer; margin-top: 15px; transition: all 0.3s ease;">Jouer</button>
                </div>
                
                <!-- Niveau Moyen -->
                <div style="background: rgba(255, 165, 0, 0.1); padding: 25px; border-radius: 15px; border: 2px solid rgba(255, 165, 0, 0.3); text-align: center;">
                    <h3 style="color: #FFA500; font-size: 28px; margin-bottom: 15px;">üß† MOYEN</h3>
                    <p style="color: white; font-size: 18px; margin: 10px 0;">Niveaux compl√©t√©s:</p>
                    <p id="mediumProgress" style="color: #FFD700; font-size: 32px; font-weight: bold;">0 / 333</p>
                    <button onclick="selectDifficulty('medium')" style="padding: 12px 30px; font-size: 18px; color: white; background: #CC8800; border: 2px solid #FFA500; border-radius: 25px; cursor: pointer; margin-top: 15px; transition: all 0.3s ease;">Jouer</button>
                </div>
                
                <!-- Niveau Difficile -->
                <div style="background: rgba(255, 0, 0, 0.1); padding: 25px; border-radius: 15px; border: 2px solid rgba(255, 0, 0, 0.3); text-align: center;">
                    <h3 style="color: #FF0000; font-size: 28px; margin-bottom: 15px;">üî• DIFFICILE</h3>
                    <p style="color: white; font-size: 18px; margin: 10px 0;">Niveaux compl√©t√©s:</p>
                    <p id="hardProgress" style="color: #FFD700; font-size: 32px; font-weight: bold;">0 / 333</p>
                    <button onclick="selectDifficulty('hard')" style="padding: 12px 30px; font-size: 18px; color: white; background: #AA0000; border: 2px solid #FF0000; border-radius: 25px; cursor: pointer; margin-top: 15px; transition: all 0.3s ease;">Jouer</button>
                </div>
            </div>
            
            <div style="margin-top: 30px; padding: 20px; background: rgba(255, 215, 0, 0.1); border-radius: 15px; border: 2px solid rgba(255, 215, 0, 0.3);">
                <h3 style="color: #FFD700; font-size: 24px; margin-bottom: 15px; text-align: center;">üèÜ Statistiques globales</h3>
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; text-align: center;">
                    <div>
                        <p style="color: white; font-size: 16px;">Total niveaux:</p>
                        <p id="totalLevels" style="color: #FFD700; font-size: 28px; font-weight: bold;">0 / 1000</p>
                    </div>
                    <div>
                        <p style="color: white; font-size: 16px;">Pi√®ces gagn√©es:</p>
                        <p id="totalCoinsEarned" style="color: #FFD700; font-size: 28px; font-weight: bold;">0 ü™ô</p>
                    </div>
                    <div>
                        <p style="color: white; font-size: 16px;">Taux de r√©ussite:</p>
                        <p id="successRate" style="color: #FFD700; font-size: 28px; font-weight: bold;">100%</p>
                    </div>
                </div>
            </div>
        </div>
        <button id="backButtonProgress" style="padding: 15px 60px; font-size: 22px; color: white; background: rgba(255,255,255,0.2); border: 2px solid white; border-radius: 50px; cursor: pointer; transition: all 0.3s ease;">Retour</button>
    </div>
    
    <!-- Interface du magasin -->
    <div id="shopInterface">
        <h2>üõí MAGASIN</h2>
        <div class="shop-content">
            <p style="color: white; text-align: center; font-size: 20px; margin-bottom: 20px;">
                Vos pi√®ces : <span id="shopCoinsCount" style="color: #FFD700; font-weight: bold;">0</span> ü™ô
            </p>
            <div class="shop-items">
                <div class="shop-item">
                    <h3>üí° Pack d'Indices (x4)</h3>
                    <p>R√©v√®le 4 cases de votre choix avec les bonnes r√©ponses</p>
                    <p class="price">50 ü™ô</p>
                    <button onclick="buyHints()">Acheter</button>
                </div>
                <div class="shop-item">
                    <h3>‚ú® Effets de particules</h3>
                    <p>Particules scintillantes lors de la victoire</p>
                    <p class="price">110 ü™ô</p>
                    <button onclick="buyItem('particles', 110)">Acheter</button>
                </div>
                <div class="shop-item">
                    <h3>üéµ Musique d'ambiance</h3>
                    <p>Musique relaxante pendant le jeu</p>
                    <p class="price">85 ü™ô</p>
                    <button onclick="buyItem('music', 85)">Acheter</button>
                </div>
                <div class="shop-item">
                    <h3>üë§ Nouveau personnage</h3>
                    <p>Personnage avec des couleurs diff√©rentes</p>
                    <p class="price">210 ü™ô</p>
                    <button onclick="buyItem('character', 210)">Acheter</button>
                </div>
                <div class="shop-item">
                    <h3>üîµ Skin Bleu</h3>
                    <p>Les nombres s'affichent en bleu lumineux</p>
                    <p class="price">40 ü™ô</p>
                    <button onclick="buySkin('blue', 40)">Acheter</button>
                </div>
                <div class="shop-item">
                    <h3>üåà Skin Multicolore</h3>
                    <p>Chaque nombre a une couleur diff√©rente</p>
                    <p class="price">60 ü™ô</p>
                    <button onclick="buySkin('multicolor', 60)">Acheter</button>
                </div>
                <div class="shop-item">
                    <h3>‚ú® Skin Arc-en-ciel</h3>
                    <p>Couleurs qui changent progressivement</p>
                    <p class="price">85 ü™ô</p>
                    <button onclick="buySkin('rainbow', 85)">Acheter</button>
                </div>
                <div class="shop-item">
                    <h3>üíõ Skin Or</h3>
                    <p>Les nombres brillent en dor√©</p>
                    <p class="price">110 ü™ô</p>
                    <button onclick="buySkin('gold', 110)">Acheter</button>
                </div>
                <div class="shop-item">
                    <h3>üíö Skin Vert N√©on</h3>
                    <p>Vert √©lectrique ultra lumineux</p>
                    <p class="price">50 ü™ô</p>
                    <button onclick="buySkin('neongreen', 50)">Acheter</button>
                </div>
                <div class="shop-item">
                    <h3>üíú Skin Violet Royal</h3>
                    <p>Violet majestueux et √©l√©gant</p>
                    <p class="price">60 ü™ô</p>
                    <button onclick="buySkin('purple', 60)">Acheter</button>
                </div>
                <div class="shop-item">
                    <h3>üß° Skin Orange Feu</h3>
                    <p>Orange flamboyant et √©nergique</p>
                    <p class="price">45 ü™ô</p>
                    <button onclick="buySkin('orange', 45)">Acheter</button>
                </div>
                <div class="shop-item">
                    <h3>üíó Skin Rose Bubble</h3>
                    <p>Rose doux et apaisant</p>
                    <p class="price">55 ü™ô</p>
                    <button onclick="buySkin('pink', 55)">Acheter</button>
                </div>
                <div class="shop-item">
                    <h3>ü©µ Skin Cyan Glacier</h3>
                    <p>Bleu glac√© cristallin</p>
                    <p class="price">55 ü™ô</p>
                    <button onclick="buySkin('cyan', 55)">Acheter</button>
                </div>
                <div class="shop-item">
                    <h3>üíé Skin Diamant</h3>
                    <p>Blanc √©clatant comme un diamant</p>
                    <p class="price">130 ü™ô</p>
                    <button onclick="buySkin('diamond', 130)">Acheter</button>
                </div>
                <div class="shop-item">
                    <h3>üå∏ Skin Sakura</h3>
                    <p>Rose p√¢le fleur de cerisier</p>
                    <p class="price">75 ü™ô</p>
                    <button onclick="buySkin('sakura', 75)">Acheter</button>
                </div>
                <div class="shop-item">
                    <h3>üî• Skin Flamme</h3>
                    <p>Rouge et orange d√©grad√© de feu</p>
                    <p class="price">95 ü™ô</p>
                    <button onclick="buySkin('flame', 95)">Acheter</button>
                </div>
                <div class="shop-item">
                    <h3>üåä Skin Oc√©an</h3>
                    <p>Bleu profond des oc√©ans</p>
                    <p class="price">80 ü™ô</p>
                    <button onclick="buySkin('ocean', 80)">Acheter</button>
                </div>
                <div class="shop-item">
                    <h3>üçã Skin Citron</h3>
                    <p>Jaune vif et acidul√©</p>
                    <p class="price">35 ü™ô</p>
                    <button onclick="buySkin('lemon', 35)">Acheter</button>
                </div>
                <div class="shop-item">
                    <h3>üåô Skin Lune</h3>
                    <p>Argent brillant lunaire</p>
                    <p class="price">105 ü™ô</p>
                    <button onclick="buySkin('moon', 105)">Acheter</button>
                </div>
                <div class="shop-item">
                    <h3>üåü Skin Galaxie</h3>
                    <p>Violet/bleu effet spatial</p>
                    <p class="price">160 ü™ô</p>
                    <button onclick="buySkin('galaxy', 160)">Acheter</button>
                </div>
                <div class="shop-item">
                    <h3>üçÄ Skin √âmeraude</h3>
                    <p>Vert pr√©cieux √©clatant</p>
                    <p class="price">120 ü™ô</p>
                    <button onclick="buySkin('emerald', 120)">Acheter</button>
                </div>
                <div class="shop-item">
                    <h3>üî¥ Skin Rubis</h3>
                    <p>Rouge sombre de pierre pr√©cieuse</p>
                    <p class="price">135 ü™ô</p>
                    <button onclick="buySkin('ruby', 135)">Acheter</button>
                </div>
                <div class="shop-item">
                    <h3>üü£ Skin Am√©thyste</h3>
                    <p>Violet profond cristallin</p>
                    <p class="price">125 ü™ô</p>
                    <button onclick="buySkin('amethyst', 125)">Acheter</button>
                </div>
                <div class="shop-item">
                    <h3>üå∫ Skin Tropical</h3>
                    <p>M√©lange de couleurs exotiques</p>
                    <p class="price">90 ü™ô</p>
                    <button onclick="buySkin('tropical', 90)">Acheter</button>
                </div>
                <div class="shop-item">
                    <h3>‚ö° Skin √âlectrique</h3>
                    <p>Jaune √©clair ultra lumineux</p>
                    <p class="price">100 ü™ô</p>
                    <button onclick="buySkin('electric', 100)">Acheter</button>
                </div>
                <div class="shop-item">
                    <h3>üç´ Skin Chocolat</h3>
                    <p>Marron chaud et doux</p>
                    <p class="price">40 ü™ô</p>
                    <button onclick="buySkin('chocolate', 40)">Acheter</button>
                </div>
                <div class="shop-item">
                    <h3>‚ùÑÔ∏è Skin Glace</h3>
                    <p>Bleu glacial givr√©</p>
                    <p class="price">60 ü™ô</p>
                    <button onclick="buySkin('ice', 60)">Acheter</button>
                </div>
                <div class="shop-item">
                    <h3>üëë Skin Royal Premium</h3>
                    <p>Or et violet majestueux</p>
                    <p class="price">210 ü™ô</p>
                    <button onclick="buySkin('royalpremium', 210)">Acheter</button>
                </div>
            </div>
        </div>
        <button id="adButton" style="padding: 20px 60px; font-size: 24px; color: white; background: linear-gradient(135deg, #FF6B6B 0%, #4ECDC4 100%); border: 3px solid #FFD700; border-radius: 50px; cursor: pointer; transition: all 0.3s ease; margin-bottom: 20px; font-weight: bold; box-shadow: 0 4px 15px rgba(255, 215, 0, 0.5);">üçø Regarder une Pub (+5 pi√®ces) üçø</button>
        <button id="backButtonShop" style="padding: 15px 60px; font-size: 22px; color: white; background: rgba(255,255,255,0.2); border: 2px solid white; border-radius: 50px; cursor: pointer; transition: all 0.3s ease;">Retour</button>
    </div>
    
    <!-- Interface de publicit√© -->
    <div id="adInterface" style="position: fixed; width: 100%; height: 100vh; background: linear-gradient(135deg, #FF6B6B 0%, #4ECDC4 100%); display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 1002;">
        <div style="background: rgba(0, 0, 0, 0.9); padding: 60px; border-radius: 30px; border: 4px solid #FFD700; max-width: 700px; text-align: center;">
            <h2 style="color: #FFD700; font-size: 56px; margin-bottom: 20px; text-shadow: 0 4px 8px rgba(0,0,0,0.5);">üçø POPCORNS MEDIA üçø</h2>
            <p style="color: white; font-size: 28px; margin: 20px 0;">Regardez cette publicit√© et gagnez</p>
            <p style="color: #FFD700; font-size: 48px; font-weight: bold; margin: 20px 0;">+5 PI√àCES ü™ô</p>
            <div style="background: rgba(255, 107, 107, 0.2); padding: 30px; border-radius: 20px; margin: 30px 0; border: 2px solid rgba(255, 255, 255, 0.3);">
                <p style="color: white; font-size: 24px; margin: 10px 0;">üé¨ Profitez de vos moments de d√©tente</p>
                <p style="color: white; font-size: 24px; margin: 10px 0;">üéÆ Jouez, gagnez, recommencez !</p>
                <p style="color: #4ECDC4; font-size: 20px; margin: 15px 0; font-style: italic;">Merci de soutenir ce jeu gratuit</p>
            </div>
            <p id="adTimer" style="color: #FFD700; font-size: 32px; font-weight: bold; margin: 20px 0;">Temps restant: 5s</p>
            <button id="closeAdButton" style="padding: 20px 50px; font-size: 24px; color: white; background: #00AA00; border: 3px solid #FFD700; border-radius: 50px; cursor: pointer; transition: all 0.3s ease; display: none;" onclick="closeAd()">R√©cup√©rer les pi√®ces ‚ú®</button>
        </div>
    </div>
    
    <!-- Interface des contr√¥les -->
    <div id="controlsInterface">
        <h2>CONTR√îLES</h2>
        <div class="controls-content">
            <div class="controls-section">
                <h3>üé≤ Jouer au Sudoku</h3>
                <p><strong>Clic gauche :</strong> S√©lectionner une case vide</p>
                <p><strong>1-9 :</strong> Entrer un chiffre dans la case</p>
                <p><strong>Delete / Suppr :</strong> Effacer un chiffre</p>
                <p><strong>Utiliser Indice :</strong> Remplir automatiquement 4 cases (co√ªte des indices)</p>
            </div>
            
            <div class="controls-section">
                <h3>üéÆ Modes de vue</h3>
                <p><strong>V :</strong> Basculer entre vue FPS et vue spectateur</p>
                <p><strong>Souris :</strong> Regarder autour (mode FPS) / Pivoter cam√©ra (spectateur)</p>
                <p><strong>Molette :</strong> Zoom / D√©zoom (mode spectateur uniquement)</p>
                <p><strong>Echap :</strong> Quitter le mode premi√®re personne</p>
            </div>
            
            <div class="controls-section">
                <h3>‚èµÔ∏è D√©placement (vue FPS)</h3>
                <p><strong>Z / ‚Üë :</strong> Avancer</p>
                <p><strong>S / ‚Üì :</strong> Reculer</p>
                <p><strong>Q / ‚Üê :</strong> Aller √† gauche</p>
                <p><strong>D / ‚Üí :</strong> Aller √† droite</p>
            </div>
            
            <div class="controls-section">
                <h3>‚öôÔ∏è Interface & Menu</h3>
                <p><strong>A :</strong> Afficher/Masquer les contr√¥les en jeu</p>
                <p><strong>H :</strong> Afficher/Masquer les r√®gles du Sudoku</p>
                <p><strong>Bouton Retour :</strong> Retourner au menu principal</p>
                <p><strong>Boutton Indice :</strong> Acheter dans le magasin (50 pi√®ces pour 4 indices)</p>
            </div>
            
            <div class="controls-section">
                <h3>üèÜ Progression</h3>
                <p><strong>Victoire :</strong> +10 pi√®ces par niveau compl√©t√©</p>
                <p><strong>Publicit√© :</strong> +5 pi√®ces (dans le magasin)</p>
                <p><strong>Niveaux :</strong> 334 facile / 333 moyen / 333 difficile</p>
                <p><strong>Skins :</strong> Achetables avec les pi√®ces (changent les couleurs)</p>
            </div>
        </div>
        <button id="backButtonControls">Retour</button>
    </div>

    <!-- Canvas pour le jeu -->
    <canvas id="renderCanvas"></canvas>

    <script>
        // Cache localStorage pour optimisation (d√©claration unique)
        let coinsCache = parseInt(localStorage.getItem('sudokuCoins') || '0');
        
        // Charger et afficher le compteur de pi√®ces dans le menu
        const menuCoinsCount = document.getElementById('menuCoinsCount');
        const shopCoinsCount = document.getElementById('shopCoinsCount');
        menuCoinsCount.textContent = coinsCache;
        shopCoinsCount.textContent = coinsCache;
        
        // Fonctions de gestion des pi√®ces
        function getCoins() {
            return coinsCache;
        }
        
        function setCoins(value) {
            coinsCache = value;
            localStorage.setItem('sudokuCoins', value.toString());
            updateCoinDisplays();
        }
        
        function updateCoinDisplays() {
            const coins = getCoins();
            menuCoinsCount.textContent = coins;
            const shopCoins = document.getElementById('shopCoinsCount');
            if (shopCoins) shopCoins.textContent = coins;
        }
        
        // Syst√®me de notifications optimis√©
        function showNotification(message, duration = 3000) {
            const notification = document.createElement('div');
            notification.className = 'notification';
            notification.textContent = message;
            document.body.appendChild(notification);
            setTimeout(() => notification.remove(), duration);
        }
        
        // Fonction pour acheter un article (optimis√©e)
        function buyItem(itemId, price) {
            const currentCoins = getCoins();
            const ownedItems = JSON.parse(localStorage.getItem('ownedItems') || '{}');
            
            if (ownedItems[itemId]) {
                showNotification('‚ö†Ô∏è D√©j√† poss√©d√© !', 2000);
                return;
            }
            
            if (currentCoins >= price) {
                setCoins(currentCoins - price);
                ownedItems[itemId] = true;
                localStorage.setItem('ownedItems', JSON.stringify(ownedItems));
                
                showNotification('‚úÖ Article d√©bloqu√© !');
                setTimeout(() => location.reload(), 500);
            } else {
                showNotification('‚ùå Manque ' + (price - currentCoins) + ' pi√®ces !', 2000);
            }
        }
        
        // Fonction pour acheter des indices
        function buyHints() {
            const currentCoins = getCoins();
            
            if (currentCoins >= 50) {
                setCoins(currentCoins - 50);
                
                const currentHints = parseInt(localStorage.getItem('availableHints') || '0');
                const newHints = currentHints + 4;
                localStorage.setItem('availableHints', newHints.toString());
                
                showNotification('‚úÖ Achat r√©ussi ! ' + newHints + ' indices disponibles');
            } else {
                showNotification('‚ùå Pas assez de pi√®ces ! (50 requis)', 2000);
            }
        }
        
        // Fonction pour regarder une publicit√© (optimis√©e avec requestAnimationFrame)
        let adTimeRemaining = 5;
        let adAnimationId = null;
        let adStartTime = 0;
        
        function watchAd() {
            const adInterface = document.getElementById('adInterface');
            const adTimer = document.getElementById('adTimer');
            const closeAdButton = document.getElementById('closeAdButton');
            
            adInterface.style.display = 'flex';
            adTimeRemaining = 5;
            adStartTime = Date.now();
            closeAdButton.style.display = 'none';
            
            function updateAdTimer() {
                const elapsed = Math.floor((Date.now() - adStartTime) / 1000);
                const remaining = 5 - elapsed;
                
                if (remaining > 0) {
                    adTimer.textContent = 'Temps restant: ' + remaining + 's';
                    adAnimationId = requestAnimationFrame(updateAdTimer);
                } else {
                    adTimer.textContent = '‚úÖ Publicit√© termin√©e !';
                    closeAdButton.style.display = 'block';
                    cancelAnimationFrame(adAnimationId);
                }
            }
            
            updateAdTimer();
        }
        
        function closeAd() {
            const adInterface = document.getElementById('adInterface');
            
            setCoins(getCoins() + 5);
            adInterface.style.display = 'none';
            if (adAnimationId) cancelAnimationFrame(adAnimationId);
            
            showNotification('üéâ +5 pi√®ces ajout√©es ! Total: ' + getCoins() + ' ü™ô');
        }
        
        // Fonction pour acheter un skin (optimis√©e)
        function buySkin(skinName, price) {
            const currentCoins = getCoins();
            
            if (currentCoins >= price) {
                setCoins(currentCoins - price);
                localStorage.setItem('activeSkin', skinName);
                
                showNotification('‚úÖ Skin "' + skinName + '" activ√© !');
                setTimeout(() => location.reload(), 500); // D√©lai pour voir la notification
            } else {
                showNotification('‚ùå Manque ' + (price - currentCoins) + ' pi√®ces !', 2000);
            }
        }
        
        // Fonction pour obtenir la couleur selon le skin actif
        function getCurrentColor(number) {
            const skin = localStorage.getItem('activeSkin') || 'red';
            
            switch(skin) {
                case 'blue':
                    return { r: 0.2, g: 0.5, b: 2.5, hex: '#4488FF' };
                case 'multicolor':
                    const colors = [
                        { r: 2.5, g: 0, b: 0, hex: '#FF0000' },
                        { r: 0, g: 2, b: 0, hex: '#00FF00' },
                        { r: 0.2, g: 0.5, b: 2.5, hex: '#4488FF' },
                        { r: 2.5, g: 2, b: 0, hex: '#FFFF00' },
                        { r: 2.5, g: 0.5, b: 0, hex: '#FF8800' },
                        { r: 2, g: 0, b: 2, hex: '#FF00FF' },
                        { r: 0, g: 2, b: 2, hex: '#00FFFF' },
                        { r: 2.5, g: 2.5, b: 2.5, hex: '#FFFFFF' },
                        { r: 2, g: 1.5, b: 0, hex: '#FFD700' }
                    ];
                    return colors[number - 1] || colors[0];
                case 'rainbow':
                    return { r: 1.5, g: 0, b: 0, hex: 'red', isRainbow: true };
                case 'gold':
                    return { r: 2.5, g: 2, b: 0, hex: '#FFD700', animatedLight: false };
                case 'neongreen':
                    return { r: 0, g: 2.5, b: 0.3, hex: '#00FF00' };
                case 'purple':
                    return { r: 1.5, g: 0, b: 2.5, hex: '#9933FF' };
                case 'orange':
                    return { r: 2.5, g: 1, b: 0, hex: '#FF6600' };
                case 'pink':
                    return { r: 2.5, g: 0.8, b: 1.8, hex: '#FF66CC' };
                case 'cyan':
                    return { r: 0, g: 2, b: 2.5, hex: '#00DDFF' };
                case 'diamond':
                    return { r: 2.8, g: 2.8, b: 3, hex: '#FFFFFF', animatedLight: true };
                case 'sakura':
                    return { r: 2.5, g: 1.2, b: 1.6, hex: '#FFB3D9' };
                case 'flame':
                    return { r: 2.8, g: 0.8, b: 0, hex: '#FF3300' };
                case 'ocean':
                    return { r: 0, g: 0.8, b: 2.5, hex: '#0066CC' };
                case 'lemon':
                    return { r: 2.8, g: 2.8, b: 0.3, hex: '#FFFF00' };
                case 'moon':
                    return { r: 2.2, g: 2.2, b: 2.5, hex: '#CCCCFF' };
                case 'galaxy':
                    return { r: 1.5, g: 0.5, b: 2.8, hex: '#6633FF', animatedLight: true };
                case 'emerald':
                    return { r: 0.2, g: 2.5, b: 0.8, hex: '#00CC66', animatedLight: true };
                case 'ruby':
                    return { r: 2.5, g: 0, b: 0.3, hex: '#CC0033', animatedLight: true };
                case 'amethyst':
                    return { r: 2, g: 0.3, b: 2.5, hex: '#9933CC', animatedLight: true };
                case 'tropical':
                    return { r: 2.5, g: 1.8, b: 0.3, hex: '#FF9900' };
                case 'electric':
                    return { r: 2.8, g: 2.8, b: 0, hex: '#FFFF00' };
                case 'chocolate':
                    return { r: 1.5, g: 0.8, b: 0.3, hex: '#8B4513' };
                case 'ice':
                    return { r: 0.5, g: 2, b: 2.8, hex: '#AAE6FF' };
                case 'royalpremium':
                    return { r: 2.5, g: 1.5, b: 2, hex: '#CC99FF', animatedLight: true };
                default:
                    return { r: 1.5, g: 0, b: 0, hex: 'red' };
            }
        }
        
        // Cr√©er la sc√®ne 3D de fond pour le menu
        const menuCanvas = document.getElementById('menuCanvas');
        const menuEngine = new BABYLON.Engine(menuCanvas, true);
        const menuScene = new BABYLON.Scene(menuEngine);
        menuScene.clearColor = new BABYLON.Color4(0, 0, 0, 0); // Transparent
        
        // Cam√©ra pour le fond
        const menuCamera = new BABYLON.ArcRotateCamera("menuCamera", 0, Math.PI / 4, 25, BABYLON.Vector3.Zero(), menuScene);
        
        // Lumi√®re douce pour le fond
        const menuLight = new BABYLON.HemisphericLight("menuLight", new BABYLON.Vector3(0, 1, 0), menuScene);
        menuLight.intensity = 0.8;
        
        // Cr√©er une grille Sudoku simplifi√©e pour le fond
        const menuGridMaterial = new BABYLON.StandardMaterial("menuGridMat", menuScene);
        menuGridMaterial.diffuseColor = new BABYLON.Color3(1, 1, 1);
        menuGridMaterial.alpha = 0.6;
        
        const menuGrid = new BABYLON.TransformNode("menuGrid", menuScene);
        
        for (let i = 0; i < 9; i++) {
            for (let j = 0; j < 9; j++) {
                const box = BABYLON.MeshBuilder.CreateBox(`menuBox_${i}_${j}`, {
                    width: 0.9,
                    height: 0.2,
                    depth: 0.9
                }, menuScene);
                box.position.set(i - 4, 0, j - 4);
                box.material = menuGridMaterial;
                box.parent = menuGrid;
            }
        }
        
        // Animation de rotation douce et visible
        menuScene.registerBeforeRender(() => {
            menuGrid.rotation.y += 0.005; // Rotation douce mais bien visible
            menuGrid.rotation.x = Math.sin(Date.now() * 0.0001) * 0.15; // L√©ger mouvement vertical
        });
        
        menuEngine.runRenderLoop(() => {
            menuScene.render();
        });
        
        // Gestion du menu
        const menuInterface = document.getElementById('menuInterface');
        const creditsInterface = document.getElementById('creditsInterface');
        const controlsInterface = document.getElementById('controlsInterface');
        const shopInterface = document.getElementById('shopInterface');
        const progressInterface = document.getElementById('progressInterface');
        const renderCanvas = document.getElementById('renderCanvas');
        const playButton = document.getElementById('playButton');
        const creditsButton = document.getElementById('creditsButton');
        const controlsButton = document.getElementById('controlsButton');
        const shopButton = document.getElementById('shopButton');
        const progressButton = document.getElementById('progressButton');
        const adButton = document.getElementById('adButton');
        const backButton = document.getElementById('backButton');
        const backButtonControls = document.getElementById('backButtonControls');
        const backButtonShop = document.getElementById('backButtonShop');
        const backButtonProgress = document.getElementById('backButtonProgress');
        
        // Syst√®me de progression
        let currentDifficulty = 'easy';
        let currentLevel = 1;
        
        // Fonction pour charger et afficher la progression
        function updateProgressDisplay() {
            const easyCompleted = parseInt(localStorage.getItem('sudoku_easy_completed') || '0');
            const mediumCompleted = parseInt(localStorage.getItem('sudoku_medium_completed') || '0');
            const hardCompleted = parseInt(localStorage.getItem('sudoku_hard_completed') || '0');
            const totalCompleted = easyCompleted + mediumCompleted + hardCompleted;
            const totalCoins = parseInt(localStorage.getItem('sudokuCoins') || '0');
            
            document.getElementById('easyProgress').textContent = easyCompleted + ' / 334';
            document.getElementById('mediumProgress').textContent = mediumCompleted + ' / 333';
            document.getElementById('hardProgress').textContent = hardCompleted + ' / 333';
            document.getElementById('totalLevels').textContent = totalCompleted + ' / 1000';
            document.getElementById('totalCoinsEarned').textContent = totalCoins + ' ü™ô';
            
            const successRate = totalCompleted > 0 ? 100 : 0; // Toujours 100% car on compte que les r√©ussites
            document.getElementById('successRate').textContent = successRate + '%';
        }
        
        // Fonction pour s√©lectionner une difficult√©
        function selectDifficulty(difficulty) {
            currentDifficulty = difficulty;
            const completed = parseInt(localStorage.getItem('sudoku_' + difficulty + '_completed') || '0');
            currentLevel = completed + 1; // Prochain niveau √† jouer
            
            const maxLevel = difficulty === 'easy' ? 334 : 333;
            if (currentLevel > maxLevel) {
                alert('üéâ F√©licitations ! Vous avez termin√© tous les niveaux ' + difficulty.toUpperCase() + ' !');
                return;
            }
            
            // Cacher le menu de progression et d√©marrer le jeu
            progressInterface.style.display = 'none';
            menuInterface.style.display = 'none';
            renderCanvas.classList.add('active');
            startGame();
        }
        
        // Rendre la fonction accessible globalement
        window.selectDifficulty = selectDifficulty;

        // Bouton Play - Lance le jeu avec difficult√© facile niveau 1
        playButton.addEventListener('click', function() {
            currentDifficulty = 'easy';
            currentLevel = parseInt(localStorage.getItem('sudoku_easy_completed') || '0') + 1;
            if (currentLevel > 334) currentLevel = 1;
            
            menuInterface.style.display = 'none';
            renderCanvas.classList.add('active');
            startGame();
        });

        // Bouton Cr√©dits - Affiche les cr√©dits
        creditsButton.addEventListener('click', function() {
            menuInterface.style.display = 'none';
            creditsInterface.style.display = 'flex';
        });
        
        // Bouton Publicit√© - Lance une pub pour gagner 5 pi√®ces
        adButton.addEventListener('click', function() {
            watchAd();
        });
        
        // Bouton Progression - Affiche la progression
        progressButton.addEventListener('click', function() {
            updateProgressDisplay();
            menuInterface.style.display = 'none';
            progressInterface.style.display = 'flex';
        });
        
        // Bouton Contr√¥les - Affiche les contr√¥les
        controlsButton.addEventListener('click', function() {
            menuInterface.style.display = 'none';
            controlsInterface.style.display = 'flex';
        });
        
        // Bouton Magasin - Affiche le magasin (optimis√©)
        shopButton.addEventListener('click', function() {
            menuInterface.style.display = 'none';
            shopInterface.style.display = 'flex';
            updateCoinDisplays();
        });

        // Bouton Retour - Retour au menu depuis cr√©dits
        backButton.addEventListener('click', function() {
            creditsInterface.style.display = 'none';
            menuInterface.style.display = 'flex';
        });
        
        // Bouton Retour - Retour au menu depuis contr√¥les
        backButtonControls.addEventListener('click', function() {
            controlsInterface.style.display = 'none';
            menuInterface.style.display = 'flex';
        });
        
        // Bouton Retour - Retour au menu depuis magasin
        backButtonShop.addEventListener('click', function() {
            shopInterface.style.display = 'none';
            menuInterface.style.display = 'flex';
        });
        
        // Bouton Retour - Retour au menu depuis progression
        backButtonProgress.addEventListener('click', function() {
            progressInterface.style.display = 'none';
            menuInterface.style.display = 'flex';
        });

        // Fonction pour d√©marrer le jeu
        function startGame() {
            const canvas = document.getElementById('renderCanvas');
            const engine = new BABYLON.Engine(canvas, true);

            // Cr√©ation de la sc√®ne
            const scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3(0.2, 0.2, 0.3);
            scene.gravity = new BABYLON.Vector3(0, -0.15, 0);
            scene.collisionsEnabled = true;

            // Cam√©ra spectateur
            const spectatorCamera = new BABYLON.ArcRotateCamera("spectatorCamera", -Math.PI / 2, Math.PI / 4, 15, new BABYLON.Vector3(4, 0, 4), scene);
            spectatorCamera.lowerRadiusLimit = 3;  // Zoom plus proche
            spectatorCamera.upperRadiusLimit = 50; // D√©zoom plus loin
            spectatorCamera.wheelPrecision = 10;   // Zoom plus fluide avec la molette
            spectatorCamera.angularSensibilityX = 2000;
            spectatorCamera.angularSensibilityY = 2000;
            spectatorCamera.inertia = 0.95; // Inertie pour stabiliser les mouvements
            spectatorCamera.panningSensibility = 2000; // Stabiliser le panning
            spectatorCamera.lowerBetaLimit = 0.1; // Emp√™cher de descendre en dessous du sudoku (angle minimal)
            spectatorCamera.upperBetaLimit = Math.PI / 2 - 0.1; // Limite sup√©rieure pour √©viter de passer sous la grille
            
            // Variable pour compter les victoires et pi√®ces
            let totalCoins = parseInt(localStorage.getItem('sudokuCoins') || '0');
            let victories = parseInt(localStorage.getItem('sudokuVictories') || '0');

            // Cam√©ra premi√®re personne (FPS)
            const fpsCamera = new BABYLON.UniversalCamera("fpsCamera", new BABYLON.Vector3(4, 1.7, -2), scene);
            fpsCamera.applyGravity = false;
            fpsCamera.checkCollisions = true;
            fpsCamera.ellipsoid = new BABYLON.Vector3(0.3, 0.9, 0.3);
            fpsCamera.speed = 0.1;
            fpsCamera.angularSensibility = 18000; // Sensibilit√© r√©duite pour √©viter les mouvements brusques
            fpsCamera.inertia = 0.92; // Inertie mod√©r√©e pour √©viter le glissement excessif
            fpsCamera.keysUp = []; // D√©sactiver les touches par d√©faut
            fpsCamera.keysDown = [];
            fpsCamera.keysLeft = [];
            fpsCamera.keysRight = [];
            
            // Activer le verrouillage du pointeur pour le mouvement libre de la souris
            let isPointerLocked = false;

            // Activer la cam√©ra spectateur au d√©part
            scene.activeCamera = spectatorCamera;
            spectatorCamera.attachControl(canvas, true);
            let isFirstPerson = false;
            
            // Lumi√®re principale directionnelle pour les ombres
            const mainLight = new BABYLON.DirectionalLight("mainLight", new BABYLON.Vector3(-1, -2, -1), scene);
            mainLight.position = new BABYLON.Vector3(20, 40, 20);
            mainLight.intensity = 0.8;
            mainLight.diffuse = new BABYLON.Color3(1, 0.98, 0.95);
            
            // G√©n√©rateur d'ombres
            const shadowGenerator = new BABYLON.ShadowGenerator(2048, mainLight);
            shadowGenerator.useBlurExponentialShadowMap = true;
            shadowGenerator.blurKernel = 32;
            shadowGenerator.setDarkness(0.3);
            
            // Lumi√®re d'ambiance pour mode spectateur
            const ambientLight = new BABYLON.HemisphericLight("ambientLight", new BABYLON.Vector3(0, 1, 0), scene);
            ambientLight.intensity = 0.6; // Active d√®s le d√©part
            ambientLight.diffuse = new BABYLON.Color3(0.9, 0.95, 1);
            ambientLight.groundColor = new BABYLON.Color3(0.3, 0.3, 0.4);
            
            // Lumi√®re douce suppl√©mentaire pour mode FPS
            const fpsLight = new BABYLON.HemisphericLight("fpsLight", new BABYLON.Vector3(0, 1, 0), scene);
            fpsLight.intensity = 0;
            fpsLight.diffuse = new BABYLON.Color3(1, 1, 0.95);

            // Fonction pour g√©n√©rer une grille de sudoku compl√®te
            function generateCompleteSudoku(seed) {
                // Utiliser le seed pour g√©n√©rer un sudoku d√©terministe
                const random = (function(s) {
                    return function() {
                        s = Math.sin(s) * 10000;
                        return s - Math.floor(s);
                    };
                })(seed);
                
                const grid = Array(9).fill(0).map(() => Array(9).fill(0));
                const nums = [1, 2, 3, 4, 5, 6, 7, 8, 9];
                
                // Remplir la diagonale (blocs 3x3 ind√©pendants)
                for (let box = 0; box < 9; box += 3) {
                    const shuffled = [...nums].sort(() => random() - 0.5);
                    let idx = 0;
                    for (let i = 0; i < 3; i++) {
                        for (let j = 0; j < 3; j++) {
                            grid[box + i][box + j] = shuffled[idx++];
                        }
                    }
                }
                
                // R√©soudre le reste
                function isValid(row, col, num) {
                    for (let x = 0; x < 9; x++) {
                        if (grid[row][x] === num || grid[x][col] === num) return false;
                    }
                    const boxRow = Math.floor(row / 3) * 3;
                    const boxCol = Math.floor(col / 3) * 3;
                    for (let i = 0; i < 3; i++) {
                        for (let j = 0; j < 3; j++) {
                            if (grid[boxRow + i][boxCol + j] === num) return false;
                        }
                    }
                    return true;
                }
                
                function solve() {
                    for (let row = 0; row < 9; row++) {
                        for (let col = 0; col < 9; col++) {
                            if (grid[row][col] === 0) {
                                const shuffledNums = [...nums].sort(() => random() - 0.5);
                                for (let num of shuffledNums) {
                                    if (isValid(row, col, num)) {
                                        grid[row][col] = num;
                                        if (solve()) return true;
                                        grid[row][col] = 0;
                                    }
                                }
                                return false;
                            }
                        }
                    }
                    return true;
                }
                
                solve();
                return grid;
            }
            
            // Fonction pour cr√©er une grille de jeu en retirant des cellules
            function createPuzzle(solution, difficulty) {
                const puzzle = solution.map(row => [...row]);
                let cellsToRemove;
                
                // Nombre de cellules √† retirer selon la difficult√©
                switch(difficulty) {
                    case 'easy': cellsToRemove = 35; break;    // 46 cellules remplies
                    case 'medium': cellsToRemove = 45; break;  // 36 cellules remplies
                    case 'hard': cellsToRemove = 55; break;    // 26 cellules remplies
                    default: cellsToRemove = 35;
                }
                
                let removed = 0;
                while (removed < cellsToRemove) {
                    const row = Math.floor(Math.random() * 9);
                    const col = Math.floor(Math.random() * 9);
                    if (puzzle[row][col] !== 0) {
                        puzzle[row][col] = 0;
                        removed++;
                    }
                }
                
                return puzzle;
            }
            
            // G√©n√©rer la grille pour le niveau actuel
            const seed = currentLevel + (currentDifficulty === 'easy' ? 0 : currentDifficulty === 'medium' ? 334 : 667);
            const sudokuSolution = generateCompleteSudoku(seed);
            const sudokuGrid = createPuzzle(sudokuSolution, currentDifficulty);

            // Mat√©riaux am√©lior√©s
            const cellMaterial = new BABYLON.StandardMaterial("cellMat", scene);
            cellMaterial.diffuseColor = new BABYLON.Color3(0.95, 0.95, 1);
            cellMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
            cellMaterial.alpha = 0.98;
            
            // Mat√©riau pour cases vides en mode spectateur (plus lumineux et brillant)
            const cellMaterialSpectator = new BABYLON.StandardMaterial("cellMatSpectator", scene);
            cellMaterialSpectator.diffuseColor = new BABYLON.Color3(1, 1, 1);
            cellMaterialSpectator.emissiveColor = new BABYLON.Color3(0.15, 0.15, 0.2);
            cellMaterialSpectator.specularColor = new BABYLON.Color3(0, 0, 0);

            const selectedMaterial = new BABYLON.StandardMaterial("selectedMat", scene);
            selectedMaterial.diffuseColor = new BABYLON.Color3(0.4, 0.8, 1);
            selectedMaterial.emissiveColor = new BABYLON.Color3(0.2, 0.4, 0.6);
            selectedMaterial.specularColor = new BABYLON.Color3(0, 0, 0);

            const fixedMaterial = new BABYLON.StandardMaterial("fixedMat", scene);
            fixedMaterial.diffuseColor = new BABYLON.Color3(0.75, 0.75, 0.85);
            fixedMaterial.specularColor = new BABYLON.Color3(0, 0, 0);

            const lineMaterial = new BABYLON.StandardMaterial("lineMat", scene);
            lineMaterial.diffuseColor = new BABYLON.Color3(0.15, 0.15, 0.25);
            lineMaterial.emissiveColor = new BABYLON.Color3(0.05, 0.05, 0.1);
            lineMaterial.specularColor = new BABYLON.Color3(0, 0, 0);

            // Stocker les cellules
            const cells = [];
            let selectedCell = null;

            // Sol invisible pour collision
            const ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 15, height: 15}, scene);
            ground.position.y = -0.15;
            ground.checkCollisions = true;
            ground.isVisible = false;

            // Cr√©er la grille 3D
            for (let row = 0; row < 9; row++) {
                cells[row] = [];
                for (let col = 0; col < 9; col++) {
                    // Cr√©er la cellule (cube)
                    const cell = BABYLON.MeshBuilder.CreateBox(`cell_${row}_${col}`, {
                        width: 0.9,
                        height: 0.2,
                        depth: 0.9
                    }, scene);
                    
                    cell.position.set(col, 0, row);
                    cell.value = sudokuGrid[row][col];
                    cell.row = row;
                    cell.col = col;
                    cell.isFixed = sudokuGrid[row][col] !== 0;
                    cell.checkCollisions = false; // Pas de collision avec les cases
                    
                    cell.material = cell.isFixed ? fixedMaterial : cellMaterialSpectator; // Utiliser le mat√©riau spectateur au d√©part
                    
                    // Ajouter les ombres aux cellules
                    shadowGenerator.addShadowCaster(cell);
                    cell.receiveShadows = true;
                    
                    // Cr√©er le texte pour le chiffre
                    if (cell.value !== 0) {
                        const textPlane = BABYLON.MeshBuilder.CreatePlane(`text_${row}_${col}`, {
                            width: 0.85,
                            height: 0.85
                        }, scene);
                        textPlane.position.set(col, 0.15, row);
                        textPlane.rotation.x = Math.PI / 2;
                        
                        const textTexture = new BABYLON.DynamicTexture(`textTexture_${row}_${col}`, 256, scene);
                        const textMaterial = new BABYLON.StandardMaterial(`textMat_${row}_${col}`, scene);
                        textMaterial.diffuseTexture = textTexture;
                        // Les nombres fixes seront tr√®s lumineux en mode spectateur
                        if (cell.isFixed) {
                            textMaterial.emissiveColor = new BABYLON.Color3(1.5, 1.5, 1.5); // Tr√®s tr√®s lumineux au d√©part (mode spectateur)
                        } else {
                            textMaterial.emissiveColor = new BABYLON.Color3(0.3, 0.3, 0.3); // Peu lumineux pour les nombres modifiables
                        }
                        textMaterial.backFaceCulling = false;
                        textPlane.material = textMaterial;
                        
                        textTexture.drawText(cell.value.toString(), null, 140, "bold 200px Arial", "white", "transparent");
                        
                        cell.textPlane = textPlane;
                        cell.textTexture = textTexture;
                        cell.textMaterial = textMaterial; // Stocker le mat√©riau pour le modifier plus tard
                    }
                    
                    cells[row][col] = cell;
                }
            }

            // Cr√©er les lignes de s√©paration des blocs 3x3
            for (let i = 0; i <= 9; i++) {
                const isThick = i % 3 === 0;
                const thickness = isThick ? 0.15 : 0.05;
                
                // Lignes horizontales
                const lineH = BABYLON.MeshBuilder.CreateBox(`lineH_${i}`, {
                    width: 9,
                    height: 0.25,
                    depth: thickness
                }, scene);
                lineH.position.set(4, 0.13, i - 0.5);
                lineH.material = lineMaterial;
                
                // Lignes verticales
                const lineV = BABYLON.MeshBuilder.CreateBox(`lineV_${i}`, {
                    width: thickness,
                    height: 0.25,
                    depth: 9
                }, scene);
                lineV.position.set(i - 0.5, 0.13, 4);
                lineV.material = lineMaterial;
            }

            // Cr√©er le personnage joueur
            const player = new BABYLON.TransformNode("player", scene);
            player.position = new BABYLON.Vector3(4, 0, -2);

            // Torse
            const torso = BABYLON.MeshBuilder.CreateBox("torso", {width: 0.5, height: 0.6, depth: 0.3}, scene);
            torso.position.y = 1.2;
            torso.parent = player;
            
            // Bassin
            const pelvis = BABYLON.MeshBuilder.CreateBox("pelvis", {width: 0.45, height: 0.3, depth: 0.3}, scene);
            pelvis.position.y = 0.7;
            pelvis.parent = player;
            
            // T√™te
            const head = BABYLON.MeshBuilder.CreateSphere("head", {diameter: 0.35}, scene);
            head.position.y = 1.65;
            head.parent = player;
            
            // Cou
            const neck = BABYLON.MeshBuilder.CreateCylinder("neck", {height: 0.15, diameter: 0.15}, scene);
            neck.position.y = 1.5;
            neck.parent = player;
            
            // √âpaule gauche
            const leftShoulder = BABYLON.MeshBuilder.CreateSphere("leftShoulder", {diameter: 0.18}, scene);
            leftShoulder.position.set(-0.27, 1.45, 0);
            leftShoulder.parent = player;
            
            // Bras gauche
            const leftArm = BABYLON.MeshBuilder.CreateCylinder("leftArm", {height: 0.5, diameter: 0.1}, scene);
            leftArm.position.set(0, -0.25, 0);
            leftArm.parent = leftShoulder;
            
            // Main gauche
            const leftHand = BABYLON.MeshBuilder.CreateSphere("leftHand", {diameter: 0.12}, scene);
            leftHand.position.set(0, -0.25, 0);
            leftHand.parent = leftArm;
            
            // √âpaule droite
            const rightShoulder = BABYLON.MeshBuilder.CreateSphere("rightShoulder", {diameter: 0.18}, scene);
            rightShoulder.position.set(0.27, 1.45, 0);
            rightShoulder.parent = player;
            
            // Bras droit
            const rightArm = BABYLON.MeshBuilder.CreateCylinder("rightArm", {height: 0.5, diameter: 0.1}, scene);
            rightArm.position.set(0, -0.25, 0);
            rightArm.parent = rightShoulder;
            
            // Main droite
            const rightHand = BABYLON.MeshBuilder.CreateSphere("rightHand", {diameter: 0.12}, scene);
            rightHand.position.set(0, -0.25, 0);
            rightHand.parent = rightArm;
            
            // Jambe gauche (cuisse)
            const leftThigh = BABYLON.MeshBuilder.CreateCylinder("leftThigh", {height: 0.4, diameter: 0.15}, scene);
            leftThigh.position.set(-0.12, 0.35, 0);
            leftThigh.parent = player;
            
            // Genou gauche
            const leftKnee = BABYLON.MeshBuilder.CreateSphere("leftKnee", {diameter: 0.16}, scene);
            leftKnee.position.set(-0.12, 0.15, 0);
            leftKnee.parent = player;
            
            // Mollet gauche
            const leftCalf = BABYLON.MeshBuilder.CreateCylinder("leftCalf", {height: 0.35, diameter: 0.12}, scene);
            leftCalf.position.set(-0.12, -0.025, 0);
            leftCalf.parent = player;
            
            // Jambe droite (cuisse)
            const rightThigh = BABYLON.MeshBuilder.CreateCylinder("rightThigh", {height: 0.4, diameter: 0.15}, scene);
            rightThigh.position.set(0.12, 0.35, 0);
            rightThigh.parent = player;
            
            // Genou droit
            const rightKnee = BABYLON.MeshBuilder.CreateSphere("rightKnee", {diameter: 0.16}, scene);
            rightKnee.position.set(0.12, 0.15, 0);
            rightKnee.parent = player;
            
            // Mollet droit
            const rightCalf = BABYLON.MeshBuilder.CreateCylinder("rightCalf", {height: 0.35, diameter: 0.12}, scene);
            rightCalf.position.set(0.12, -0.025, 0);
            rightCalf.parent = player;
            
            // Mat√©riau du personnage am√©lior√©
            const playerMat = new BABYLON.StandardMaterial("playerMat", scene);
            playerMat.diffuseColor = new BABYLON.Color3(0.3, 0.7, 1);
            playerMat.specularColor = new BABYLON.Color3(0, 0, 0);
            playerMat.emissiveColor = new BABYLON.Color3(0.05, 0.1, 0.2);
            
            // Appliquer le mat√©riau et les ombres au personnage
            const playerParts = [torso, pelvis, head, neck, leftShoulder, leftArm, rightShoulder, rightArm, 
                                leftThigh, leftKnee, leftCalf, rightThigh, rightKnee, rightCalf];
            playerParts.forEach(part => {
                part.material = playerMat;
                shadowGenerator.addShadowCaster(part);
            });
            
            // Mat√©riau pour les mains
            const handMat = new BABYLON.StandardMaterial("handMat", scene);
            handMat.diffuseColor = new BABYLON.Color3(1, 0.85, 0.7);
            handMat.specularColor = new BABYLON.Color3(0, 0, 0);
            leftHand.material = handMat;
            rightHand.material = handMat;
            shadowGenerator.addShadowCaster(leftHand);
            shadowGenerator.addShadowCaster(rightHand);

            // Contr√¥les de d√©placement
            const keys = {};
            window.addEventListener('keydown', (e) => keys[e.key.toLowerCase()] = true);
            window.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);

            // Basculer entre les vues
            window.addEventListener('keydown', function(evt) {
                if (evt.key === 'v' || evt.key === 'V') {
                    isFirstPerson = !isFirstPerson;
                    
                    if (isFirstPerson) {
                        // Mode premi√®re personne
                        scene.activeCamera = fpsCamera;
                        fpsCamera.attachControl(canvas, true);
                        spectatorCamera.detachControl();
                        
                        // Activer le verrouillage du pointeur pour mouvement libre de la souris
                        canvas.requestPointerLock = canvas.requestPointerLock || canvas.mozRequestPointerLock || canvas.webkitRequestPointerLock;
                        if (canvas.requestPointerLock) {
                            canvas.requestPointerLock();
                        }
                        
                        // Cacher toutes les parties du corps
                        player.getChildMeshes().forEach(mesh => mesh.isVisible = false);
                        // Activer les lumi√®res pour mode FPS
                        ambientLight.intensity = 0.4;
                        fpsLight.intensity = 0.5;
                        
                        // Afficher le r√©ticule de vis√©e
                        crosshair.isVisible = true;
                        crosshairH.isVisible = true;
                        crosshairV.isVisible = true;
                        
                        // R√©duire la luminosit√© des nombres fixes
                        for (let row = 0; row < 9; row++) {
                            for (let col = 0; col < 9; col++) {
                                const cell = cells[row][col];
                                if (cell.isFixed && cell.textMaterial) {
                                    cell.textMaterial.emissiveColor = new BABYLON.Color3(0.2, 0.2, 0.2);
                                }
                                // Changer le mat√©riau des cases vides en mode FPS
                                if (!cell.isFixed && cell.material !== selectedMaterial) {
                                    cell.material = cellMaterial;
                                }
                            }
                        }
                    } else {
                        // Mode spectateur
                        scene.activeCamera = spectatorCamera;
                        spectatorCamera.attachControl(canvas, true);
                        fpsCamera.detachControl();
                        
                        // D√©sactiver le verrouillage du pointeur
                        document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock;
                        if (document.exitPointerLock) {
                            document.exitPointerLock();
                        }
                        
                        // Cacher toutes les parties du corps en mode spectateur
                        player.getChildMeshes().forEach(mesh => mesh.isVisible = false);
                        // Ajuster les lumi√®res pour mode spectateur
                        ambientLight.intensity = 0.6;
                        fpsLight.intensity = 0;
                        
                        // Masquer le r√©ticule de vis√©e
                        crosshair.isVisible = false;
                        crosshairH.isVisible = false;
                        crosshairV.isVisible = false;
                        
                        // Augmenter la luminosit√© des nombres fixes (tr√®s lumineux)
                        for (let row = 0; row < 9; row++) {
                            for (let col = 0; col < 9; col++) {
                                const cell = cells[row][col];
                                if (cell.isFixed && cell.textMaterial) {
                                    cell.textMaterial.emissiveColor = new BABYLON.Color3(1.5, 1.5, 1.5); // Tr√®s tr√®s lumineux
                                }
                                // Rendre les cases vides plus claires en mode spectateur
                                if (!cell.isFixed && cell.material !== selectedMaterial) {
                                    cell.material = cellMaterialSpectator;
                                }
                            }
                        }
                    }
                }
            });

            // Gestion de la s√©lection
            scene.onPointerDown = function(evt, pickResult) {
                // Seulement sur clic gauche
                if (evt.button !== 0) return;
                
                let pickedCell = null;
                
                if (isFirstPerson) {
                    // En mode FPS, faire un raycast depuis le centre de l'√©cran
                    const ray = fpsCamera.getForwardRay();
                    const hit = scene.pickWithRay(ray);
                    
                    if (hit.hit && hit.pickedMesh) {
                        // Si on clique sur une cellule
                        if (hit.pickedMesh.name.startsWith('cell_')) {
                            pickedCell = hit.pickedMesh;
                        }
                        // Si on clique sur un texte (nombre rouge), retrouver la cellule correspondante
                        else if (hit.pickedMesh.name.startsWith('text_')) {
                            const coords = hit.pickedMesh.name.split('_');
                            const row = parseInt(coords[1]);
                            const col = parseInt(coords[2]);
                            pickedCell = cells[row][col];
                        }
                    }
                } else {
                    // En mode spectateur, utiliser le pickResult normal
                    if (pickResult.hit && pickResult.pickedMesh) {
                        // Si on clique sur une cellule
                        if (pickResult.pickedMesh.name.startsWith('cell_')) {
                            pickedCell = pickResult.pickedMesh;
                        }
                        // Si on clique sur un texte (nombre rouge), retrouver la cellule correspondante
                        else if (pickResult.pickedMesh.name.startsWith('text_')) {
                            const coords = pickResult.pickedMesh.name.split('_');
                            const row = parseInt(coords[1]);
                            const col = parseInt(coords[2]);
                            pickedCell = cells[row][col];
                        }
                    }
                }
                
                if (pickedCell && !pickedCell.isFixed) {
                    // Mode indice : remplir automatiquement avec la bonne r√©ponse
                    if (hintMode && hintsToUse > 0) {
                        const correctValue = sudokuSolution[pickedCell.row][pickedCell.col];
                        pickedCell.value = correctValue;
                        pickedCell.isFixed = true; // La rendre fixe pour qu'on ne puisse plus la modifier
                        
                        // Cr√©er ou mettre √† jour le texte
                        if (pickedCell.textPlane) {
                            pickedCell.textPlane.dispose();
                            pickedCell.textTexture.dispose();
                        }
                        
                        const textPlane = BABYLON.MeshBuilder.CreatePlane(`text_${pickedCell.row}_${pickedCell.col}`, {
                            width: 0.85,
                            height: 0.85
                        }, scene);
                        textPlane.position.set(pickedCell.col, 0.15, pickedCell.row);
                        textPlane.rotation.x = Math.PI / 2;
                        
                        const textTexture = new BABYLON.DynamicTexture(`textTexture_${pickedCell.row}_${pickedCell.col}`, 256, scene);
                        const textMaterial = new BABYLON.StandardMaterial(`textMat_${pickedCell.row}_${pickedCell.col}`, scene);
                        textMaterial.diffuseTexture = textTexture;
                        textMaterial.emissiveColor = new BABYLON.Color3(0.5, 1.5, 0.5); // Vert lumineux pour les indices
                        textMaterial.backFaceCulling = false;
                        textPlane.material = textMaterial;
                        
                        textTexture.drawText(correctValue.toString(), null, 140, "bold 200px Arial", "#00FF00", "transparent");
                        
                        pickedCell.textPlane = textPlane;
                        pickedCell.textTexture = textTexture;
                        pickedCell.textMaterial = textMaterial;
                        pickedCell.material = fixedMaterial;
                        
                        // D√©cr√©menter les indices
                        hintsToUse--;
                        hintButton.textBlock.text = "Choisissez " + hintsToUse + " case(s)";
                        
                        if (hintsToUse === 0) {
                            hintMode = false;
                            const newHintCount = parseInt(localStorage.getItem('availableHints') || '0') - 1;
                            localStorage.setItem('availableHints', newHintCount.toString());
                            updateHintButton();
                            hintButton.background = "#FFD700";
                            alert("Indices utilis√©s ! V√©rifiez si le Sudoku est r√©solu.");
                            setTimeout(checkVictory, 100);
                        }
                    } else {
                        // Mode s√©lection normal
                        // D√©s√©lectionner l'ancienne cellule
                        if (selectedCell) {
                            selectedCell.material = isFirstPerson ? cellMaterial : cellMaterialSpectator;
                        }
                        
                        // S√©lectionner la nouvelle cellule
                        selectedCell = pickedCell;
                        selectedCell.material = selectedMaterial;
                    }
                } else if (pickedCell && pickedCell.isFixed && hintMode) {
                    alert("Cette case est d√©j√† remplie ! Choisissez une case vide.");
                } else if (!pickedCell && hintMode) {
                    // Clic en dehors d'une case vide
                }
                
                if (!hintMode && pickedCell && !pickedCell.isFixed) {
                    selectedCell.material = selectedMaterial;
                }
            };

            // Gestion du clavier pour entrer les chiffres
            window.addEventListener('keydown', function(evt) {
                // Touche A pour afficher/masquer les contr√¥les ou fermer l'aide
                if (evt.key === 'a' || evt.key === 'A') {
                    if (helpPanel.isVisible) {
                        // Si le panneau d'aide est ouvert, le fermer
                        helpPanel.isVisible = false;
                        isPaused = false;
                        
                        // Rattacher les contr√¥les de cam√©ra
                        if (isFirstPerson) {
                            fpsCamera.attachControl(canvas, true);
                        } else {
                            spectatorCamera.attachControl(canvas, true);
                        }
                    } else {
                        // Sinon, basculer les contr√¥les
                        showControls = !showControls;
                        textBlock.isVisible = showControls;
                        aKeyHint.isVisible = showControls;
                        controlsBackButton.isVisible = showControls;
                    }
                }
                
                // Touche H pour afficher/masquer l'aide et mettre en pause
                if (evt.key === 'h' || evt.key === 'H') {
                    helpPanel.isVisible = !helpPanel.isVisible;
                    isPaused = helpPanel.isVisible; // Mettre en pause si le panneau est visible
                    
                    // D√©tacher/rattacher les contr√¥les de la cam√©ra
                    if (helpPanel.isVisible) {
                        // Fermer les autres panneaux (contr√¥les)
                        showControls = false;
                        textBlock.isVisible = false;
                        viewModeText.isVisible = false;
                        aKeyHint.isVisible = false;
                        
                        // D√©tacher les contr√¥les de cam√©ra
                        if (isFirstPerson) {
                            fpsCamera.detachControl();
                        } else {
                            spectatorCamera.detachControl();
                        }
                    } else {
                        // Rattacher les contr√¥les de cam√©ra
                        if (isFirstPerson) {
                            fpsCamera.attachControl(canvas, true);
                        } else {
                            spectatorCamera.attachControl(canvas, true);
                        }
                    }
                }
                
                // Ne permettre la saisie que si le jeu n'est pas en pause
                if (isPaused) return;
                
                if (selectedCell && !selectedCell.isFixed) {
                    const key = evt.key;
                    
                    if (key >= '1' && key <= '9') {
                        const num = parseInt(key);
                        selectedCell.value = num;
                        
                        // V√©rifier si le sudoku est r√©solu apr√®s chaque modification
                        setTimeout(checkVictory, 100);
                        
                        // Obtenir la couleur du skin actif
                        const color = getCurrentColor(num);
                        
                        // Mettre √† jour le texte
                        if (selectedCell.textPlane) {
                            selectedCell.textTexture.clear();
                            selectedCell.textTexture.drawText(num.toString(), null, 140, "bold 200px Arial", color.hex, "transparent");
                            selectedCell.textMaterial.emissiveColor = new BABYLON.Color3(color.r, color.g, color.b);
                            selectedCell.baseEmissive = { r: color.r, g: color.g, b: color.b };
                            selectedCell.hasAnimatedLight = color.animatedLight || false;
                        } else {
                            // Cr√©er le texte s'il n'existe pas
                            const textPlane = BABYLON.MeshBuilder.CreatePlane(`text_${selectedCell.row}_${selectedCell.col}`, {
                                width: 0.7,
                                height: 0.7
                            }, scene);
                            textPlane.position.set(selectedCell.col, 0.15, selectedCell.row);
                            textPlane.rotation.x = Math.PI / 2;
                            
                            const textTexture = new BABYLON.DynamicTexture(`textTexture_${selectedCell.row}_${selectedCell.col}`, 256, scene);
                            const textMaterial = new BABYLON.StandardMaterial(`textMat_${selectedCell.row}_${selectedCell.col}`, scene);
                            textMaterial.diffuseTexture = textTexture;
                            textMaterial.emissiveColor = new BABYLON.Color3(color.r, color.g, color.b);
                            textMaterial.backFaceCulling = false;
                            textPlane.material = textMaterial;
                            
                            textTexture.drawText(num.toString(), null, 140, "bold 200px Arial", color.hex, "transparent");
                            
                            selectedCell.textPlane = textPlane;
                            selectedCell.textTexture = textTexture;
                            selectedCell.textMaterial = textMaterial; // Stocker le mat√©riau
                            selectedCell.baseEmissive = { r: color.r, g: color.g, b: color.b };
                            selectedCell.hasAnimatedLight = color.animatedLight || false;
                        }
                    } else if (key === 'Delete' || key === 'Backspace') {
                        // Effacer le chiffre
                        selectedCell.value = 0;
                        if (selectedCell.textPlane) {
                            selectedCell.textPlane.dispose();
                            selectedCell.textTexture.dispose();
                            selectedCell.textPlane = null;
                            selectedCell.textTexture = null;
                        }
                    }
                }
            });

            // G√©rer la sortie du pointer lock avec Echap
            document.addEventListener('pointerlockchange', function() {
                if (!document.pointerLockElement && isFirstPerson) {
                    // Si on sort du pointer lock en mode FPS, retourner en mode spectateur
                    isFirstPerson = false;
                    scene.activeCamera = spectatorCamera;
                    spectatorCamera.attachControl(canvas, true);
                    fpsCamera.detachControl();
                    player.getChildMeshes().forEach(mesh => mesh.isVisible = false); // Cacher le personnage
                    ambientLight.intensity = 0;
                    
                    // Masquer le r√©ticule
                    crosshair.isVisible = false;
                    crosshairH.isVisible = false;
                    crosshairV.isVisible = false;
                    
                    // Augmenter la luminosit√© des nombres fixes
                    for (let row = 0; row < 9; row++) {
                        for (let col = 0; col < 9; col++) {
                            const cell = cells[row][col];
                            if (cell.isFixed && cell.textMaterial) {
                                cell.textMaterial.emissiveColor = new BABYLON.Color3(1, 1, 1);
                            }
                            // Rendre les cases vides plus claires
                            if (!cell.isFixed && cell.material !== selectedMaterial) {
                                cell.material = cellMaterialSpectator;
                            }
                        }
                    }
                }
            });

            // Texte d'instructions
            const advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
            const textBlock = new BABYLON.GUI.TextBlock();
            textBlock.text = "ZQSD ou Fl√®ches: Se d√©placer | V: Changer de vue | A: Afficher aide | H: R√®gles | Molette: Zoom/D√©zoom (spectateur) | Cliquez sur une case et tapez 1-9 | Delete: Effacer";
            textBlock.color = "white";
            textBlock.fontSize = 16;
            textBlock.top = "-45%";
            textBlock.isVisible = false; // Masqu√© par d√©faut
            advancedTexture.addControl(textBlock);
            
            let showControls = false; // Masqu√© par d√©faut
            
            // Variable de pause du jeu
            let isPaused = false;
            
            // R√©ticule de vis√©e pour le mode FPS (crosshair)
            const crosshair = new BABYLON.GUI.Ellipse();
            crosshair.width = "8px";
            crosshair.height = "8px";
            crosshair.color = "white";
            crosshair.thickness = 2;
            crosshair.background = "transparent";
            crosshair.isVisible = false; // Masqu√© au d√©but (mode spectateur)
            advancedTexture.addControl(crosshair);
            
            // Ligne horizontale du r√©ticule
            const crosshairH = new BABYLON.GUI.Rectangle();
            crosshairH.width = "20px";
            crosshairH.height = "2px";
            crosshairH.color = "white";
            crosshairH.thickness = 0;
            crosshairH.background = "white";
            crosshairH.isVisible = false;
            advancedTexture.addControl(crosshairH);
            
            // Ligne verticale du r√©ticule
            const crosshairV = new BABYLON.GUI.Rectangle();
            crosshairV.width = "2px";
            crosshairV.height = "20px";
            crosshairV.color = "white";
            crosshairV.thickness = 0;
            crosshairV.background = "white";
            crosshairV.isVisible = false;
            advancedTexture.addControl(crosshairV);
            
            // Indicateur touche A en haut √† droite
            const aKeyHint = new BABYLON.GUI.TextBlock();
            aKeyHint.text = "Appuyez sur A pour afficher l'aide";
            aKeyHint.color = "rgba(255, 255, 255, 0.7)";
            aKeyHint.fontSize = 18;
            aKeyHint.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
            aKeyHint.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
            aKeyHint.top = "60px";
            aKeyHint.left = "-20px";
            aKeyHint.isVisible = false; // Masqu√© par d√©faut
            advancedTexture.addControl(aKeyHint);
            
            // Affichage du niveau et de la difficult√©
            const difficultyNames = { 'easy': 'FACILE', 'medium': 'MOYEN', 'hard': 'DIFFICILE' };
            const difficultyColors = { 'easy': '#00FF00', 'medium': '#FFA500', 'hard': '#FF0000' };
            const difficultyEmojis = { 'easy': 'üë∂', 'medium': 'üß†', 'hard': 'üî•' };
            
            const levelDisplay = new BABYLON.GUI.TextBlock();
            levelDisplay.text = difficultyEmojis[currentDifficulty] + " " + difficultyNames[currentDifficulty] + " - Niveau " + currentLevel;
            levelDisplay.color = difficultyColors[currentDifficulty];
            levelDisplay.fontSize = 28;
            levelDisplay.fontWeight = "bold";
            levelDisplay.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
            levelDisplay.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
            levelDisplay.top = "20px";
            levelDisplay.left = "20px";
            levelDisplay.outlineWidth = 3;
            levelDisplay.outlineColor = "black";
            advancedTexture.addControl(levelDisplay);
            
            // Faire dispara√Ætre le niveau apr√®s 5 secondes
            setTimeout(() => {
                levelDisplay.isVisible = false;
            }, 5000);
            
            // Timer de temps (pour calcul final uniquement)
            const startTime = Date.now();
            let finalTime = 0;
            
            function formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return (mins < 10 ? '0' : '') + mins + ':' + (secs < 10 ? '0' : '') + secs;
            }
            
            // Bouton pour utiliser les indices
            let hintMode = false;
            let hintsToUse = 0;
            const hintButton = BABYLON.GUI.Button.CreateSimpleButton("hintBtn", "Utiliser Indice (0)");
            hintButton.width = "200px";
            hintButton.height = "50px";
            hintButton.color = "white";
            hintButton.background = "#FFD700";
            hintButton.cornerRadius = 10;
            hintButton.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
            hintButton.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
            hintButton.top = "120px";
            hintButton.left = "-20px";
            hintButton.onPointerClickObservable.add(() => {
                const availableHints = parseInt(localStorage.getItem('availableHints') || '0');
                if (availableHints > 0 && !hintMode) {
                    hintMode = true;
                    hintsToUse = 4;
                    hintButton.textBlock.text = "Choisissez 4 cases (" + hintsToUse + " restants)";
                    hintButton.background = "#FF6347";
                    alert("Mode indice activ√© ! Cliquez sur 4 cases vides pour les remplir automatiquement.");
                } else if (availableHints === 0) {
                    alert("Vous n'avez pas d'indices disponibles. Achetez-en dans le magasin !");
                }
            });
            advancedTexture.addControl(hintButton);
            
            // Mettre √† jour le compteur d'indices
            function updateHintButton() {
                const availableHints = parseInt(localStorage.getItem('availableHints') || '0');
                hintButton.textBlock.text = "Utiliser Indice (" + availableHints + ")";
            }
            updateHintButton();
            
            // Panneau d'aide avec r√®gles du Sudoku
            const helpPanel = new BABYLON.GUI.Rectangle();
            helpPanel.width = "600px";
            helpPanel.height = "500px";
            helpPanel.cornerRadius = 20;
            helpPanel.color = "white";
            helpPanel.thickness = 4;
            helpPanel.background = "rgba(30, 30, 50, 0.95)";
            helpPanel.isVisible = false;
            advancedTexture.addControl(helpPanel);
            
            const helpTitle = new BABYLON.GUI.TextBlock();
            helpTitle.text = "R√àGLES DU SUDOKU";
            helpTitle.color = "#FFD700";
            helpTitle.fontSize = 28;
            helpTitle.fontWeight = "bold";
            helpTitle.top = "-200px";
            helpPanel.addControl(helpTitle);
            
            const helpText = new BABYLON.GUI.TextBlock();
            helpText.text = "Remplissez la grille 9x9 avec des chiffres de 1 √† 9\n\n" +
                           "‚úì Chaque LIGNE doit contenir tous les chiffres de 1 √† 9\n" +
                           "‚úì Chaque COLONNE doit contenir tous les chiffres de 1 √† 9\n" +
                           "‚úì Chaque BLOC 3x3 doit contenir tous les chiffres de 1 √† 9\n\n" +
                           "Les cases gris fonc√© sont fixes (indices)\n" +
                           "Les cases claires sont √† remplir\n\n" +
                           "üèÜ R√©compense: +10 pi√®ces par victoire!";
            helpText.color = "white";
            helpText.fontSize = 16;
            helpText.textWrapping = true;
            helpText.lineSpacing = "3px";
            helpText.top = "-20px";
            helpPanel.addControl(helpText);
            
            // Bouton pour ouvrir la vid√©o YouTube
            const videoButton = BABYLON.GUI.Button.CreateSimpleButton("videoLink", "üì∫ Voir un exemple en vid√©o");
            videoButton.width = "250px";
            videoButton.height = "40px";
            videoButton.color = "white";
            videoButton.background = "#FF0000";
            videoButton.cornerRadius = 10;
            videoButton.top = "170px";
            videoButton.onPointerClickObservable.add(() => {
                window.open('https://www.youtube.com/watch?v=kvPuvo_Y1z4', '_blank');
            });
            helpPanel.addControl(videoButton);
            
            // Petit texte "H Fermer" en bas
            const closeHintText = new BABYLON.GUI.TextBlock();
            closeHintText.text = "H Fermer";
            closeHintText.color = "#888888";
            closeHintText.fontSize = 14;
            closeHintText.top = "220px";
            helpPanel.addControl(closeHintText);
            
            // Bouton retour accueil (fl√®che)
            const homeButton = BABYLON.GUI.Button.CreateImageOnlyButton("home", "");
            homeButton.width = "60px";
            homeButton.height = "60px";
            homeButton.cornerRadius = 30;
            homeButton.color = "white";
            homeButton.thickness = 3;
            homeButton.background = "rgba(102, 126, 234, 0.8)";
            homeButton.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
            homeButton.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
            homeButton.left = "20px";
            homeButton.top = "20px";
            homeButton.onPointerClickObservable.add(() => {
                engine.stopRenderLoop();
                scene.dispose();
                engine.dispose();
                location.reload(); // Recharger la page pour retourner au menu
            });
            advancedTexture.addControl(homeButton);
            
            // Texte fl√®che dans le bouton
            const arrowText = new BABYLON.GUI.TextBlock();
            arrowText.text = "‚¨Ö";
            arrowText.color = "white";
            arrowText.fontSize = 32;
            homeButton.addControl(arrowText);
            
            // Bouton retour dans le panneau de contr√¥les en jeu
            const controlsBackButton = BABYLON.GUI.Button.CreateSimpleButton("controlsBack", "Fermer (A)");
            controlsBackButton.width = "150px";
            controlsBackButton.height = "40px";
            controlsBackButton.color = "white";
            controlsBackButton.background = "#667eea";
            controlsBackButton.cornerRadius = 10;
            controlsBackButton.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
            controlsBackButton.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
            controlsBackButton.top = "-350px";
            controlsBackButton.isVisible = false; // Masqu√© par d√©faut
            controlsBackButton.onPointerClickObservable.add(() => {
                showControls = false;
                textBlock.isVisible = false;
                aKeyHint.isVisible = false;
                controlsBackButton.isVisible = false;
            });
            advancedTexture.addControl(controlsBackButton);
            
            // √âcran de victoire
            const victoryPanel = new BABYLON.GUI.Rectangle();
            victoryPanel.width = "700px";
            victoryPanel.height = "400px";
            victoryPanel.cornerRadius = 20;
            victoryPanel.color = "#FFD700";
            victoryPanel.thickness = 6;
            victoryPanel.background = "rgba(20, 150, 70, 0.95)";
            victoryPanel.isVisible = false;
            advancedTexture.addControl(victoryPanel);
            
            const victoryTitle = new BABYLON.GUI.TextBlock();
            victoryTitle.text = "üéâ VICTOIRE ! üéâ";
            victoryTitle.color = "#FFD700";
            victoryTitle.fontSize = 48;
            victoryTitle.fontWeight = "bold";
            victoryTitle.top = "-140px";
            victoryPanel.addControl(victoryTitle);
            
            const levelCompleteText = new BABYLON.GUI.TextBlock();
            levelCompleteText.text = "";
            levelCompleteText.color = "white";
            levelCompleteText.fontSize = 22;
            levelCompleteText.top = "-85px";
            victoryPanel.addControl(levelCompleteText);
            
            const victoryMessage = new BABYLON.GUI.TextBlock();
            victoryMessage.text = "F√©licitations !\nVous avez r√©solu le Sudoku !";
            victoryMessage.color = "white";
            victoryMessage.fontSize = 24;
            victoryMessage.top = "-30px";
            victoryPanel.addControl(victoryMessage);
            
            const timeDisplay = new BABYLON.GUI.TextBlock();
            timeDisplay.text = "‚è± Temps: 00:00";
            timeDisplay.color = "#FFD700";
            timeDisplay.fontSize = 22;
            timeDisplay.fontWeight = "bold";
            timeDisplay.top = "10px";
            victoryPanel.addControl(timeDisplay);
            
            const coinsEarned = new BABYLON.GUI.TextBlock();
            coinsEarned.text = "ü™ô +10 Pi√®ces gagn√©es !";
            coinsEarned.color = "#FFD700";
            coinsEarned.fontSize = 28;
            coinsEarned.fontWeight = "bold";
            coinsEarned.top = "50px";
            victoryPanel.addControl(coinsEarned);
            
            const totalCoinsDisplay = new BABYLON.GUI.TextBlock();
            totalCoinsDisplay.text = "Total: 0 pi√®ces";
            totalCoinsDisplay.color = "white";
            totalCoinsDisplay.fontSize = 20;
            totalCoinsDisplay.top = "90px";
            victoryPanel.addControl(totalCoinsDisplay);
            
            const nextLevelButton = BABYLON.GUI.Button.CreateSimpleButton("nextLevel", "Niveau suivant ‚û°");
            nextLevelButton.width = "200px";
            nextLevelButton.height = "50px";
            nextLevelButton.color = "white";
            nextLevelButton.background = "#00AA00";
            nextLevelButton.cornerRadius = 10;
            nextLevelButton.top = "130px";
            nextLevelButton.left = "-110px";
            nextLevelButton.fontSize = 18;
            nextLevelButton.onPointerClickObservable.add(() => {
                engine.stopRenderLoop();
                scene.dispose();
                engine.dispose();
                currentLevel++;
                const maxLevel = currentDifficulty === 'easy' ? 334 : 333;
                if (currentLevel > maxLevel) currentLevel = 1;
                location.reload();
            });
            victoryPanel.addControl(nextLevelButton);
            
            const continueButton = BABYLON.GUI.Button.CreateSimpleButton("continue", "Retour au menu");
            continueButton.width = "200px";
            continueButton.height = "50px";
            continueButton.color = "white";
            continueButton.background = "#667eea";
            continueButton.cornerRadius = 10;
            continueButton.top = "130px";
            continueButton.left = "110px";
            continueButton.fontSize = 18;
            continueButton.onPointerClickObservable.add(() => {
                location.reload();
            });
            victoryPanel.addControl(continueButton);
            
            // Fonction de validation du Sudoku
            function checkVictory() {
                // V√©rifier si toutes les cases sont remplies
                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        if (cells[row][col].value === 0) return false;
                    }
                }
                
                // V√©rifier les lignes
                for (let row = 0; row < 9; row++) {
                    const nums = new Set();
                    for (let col = 0; col < 9; col++) {
                        const val = cells[row][col].value;
                        if (nums.has(val)) return false;
                        nums.add(val);
                    }
                }
                
                // V√©rifier les colonnes
                for (let col = 0; col < 9; col++) {
                    const nums = new Set();
                    for (let row = 0; row < 9; row++) {
                        const val = cells[row][col].value;
                        if (nums.has(val)) return false;
                        nums.add(val);
                    }
                }
                
                // V√©rifier les blocs 3x3
                for (let blockRow = 0; blockRow < 3; blockRow++) {
                    for (let blockCol = 0; blockCol < 3; blockCol++) {
                        const nums = new Set();
                        for (let i = 0; i < 3; i++) {
                            for (let j = 0; j < 3; j++) {
                                const row = blockRow * 3 + i;
                                const col = blockCol * 3 + j;
                                const val = cells[row][col].value;
                                if (nums.has(val)) return false;
                                nums.add(val);
                            }
                        }
                    }
                }
                
                // Victoire !
                showVictory();
                return true;
            }
            
            function showVictory() {
                // Calculer le temps final
                finalTime = Math.floor((Date.now() - startTime) / 1000);
                
                // Ajouter 10 pi√®ces (optimis√© avec cache)
                totalCoins += 10;
                victories += 1;
                coinsCache = totalCoins;
                localStorage.setItem('sudokuCoins', totalCoins.toString());
                localStorage.setItem('sudokuVictories', victories.toString());
                
                // Marquer ce niveau comme compl√©t√© pour cette difficult√©
                const completedKey = 'sudoku_' + currentDifficulty + '_completed';
                const currentCompleted = parseInt(localStorage.getItem(completedKey) || '0');
                
                // Si c'est un nouveau niveau compl√©t√© (pas une r√©p√©tition)
                if (currentLevel > currentCompleted) {
                    localStorage.setItem(completedKey, currentLevel.toString());
                }
                
                // Mettre √† jour l'affichage
                const difficultyNames = { 'easy': 'FACILE', 'medium': 'MOYEN', 'hard': 'DIFFICILE' };
                const difficultyEmojis = { 'easy': 'üë∂', 'medium': 'üß†', 'hard': 'üî•' };
                levelCompleteText.text = difficultyEmojis[currentDifficulty] + " " + difficultyNames[currentDifficulty] + " - Niveau " + currentLevel + " compl√©t√© !";
                timeDisplay.text = "‚è± Temps: " + formatTime(finalTime);
                totalCoinsDisplay.text = "Total: " + totalCoins + " pi√®ces | Victoires: " + victories;
                
                // Afficher l'√©cran de victoire
                victoryPanel.isVisible = true;
            }

            console.log("Sudoku 3D d√©marr√© !");

            // Boucle de rendu avec d√©placement du joueur
            let walkTime = 0;
            let animationTime = 0;
            
            engine.runRenderLoop(function() {
                // Si le jeu est en pause, ne pas ex√©cuter la logique de jeu
                if (isPaused) {
                    scene.render();
                    return;
                }
                
                // Animation de lumi√®re pulsante pour les skins premium (optimis√©)
                animationTime += 0.05;
                const lightPulse = Math.sin(animationTime) * 0.4 + 1;
                
                // R√©utiliser un seul objet Color3 au lieu d'en cr√©er 81 par frame
                const tempColor = new BABYLON.Color3(0, 0, 0);
                
                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        const cell = cells[row][col];
                        if (cell.hasAnimatedLight && cell.textMaterial && cell.baseEmissive) {
                            tempColor.r = cell.baseEmissive.r * lightPulse;
                            tempColor.g = cell.baseEmissive.g * lightPulse;
                            tempColor.b = cell.baseEmissive.b * lightPulse;
                            cell.textMaterial.emissiveColor.copyFrom(tempColor);
                        }
                    }
                }
                
                // D√©placement du joueur
                const speed = 0.05; // Vitesse r√©duite pour un mouvement plus lent
                const direction = new BABYLON.Vector3(0, 0, 0);

                if (keys['z'] || keys['arrowup']) direction.z += 1;
                if (keys['s'] || keys['arrowdown']) direction.z -= 1;
                if (keys['q'] || keys['arrowleft']) direction.x -= 1;
                if (keys['d'] || keys['arrowright']) direction.x += 1;

                if (direction.length() > 0) {
                    direction.normalize();
                    walkTime += 0.1;
                    
                    // Animation de marche (balancement des bras et jambes)
                    if (!isFirstPerson) {
                        leftArm.rotation.x = Math.sin(walkTime) * 0.5;
                        rightArm.rotation.x = Math.sin(walkTime + Math.PI) * 0.5;
                        leftThigh.rotation.x = Math.sin(walkTime + Math.PI) * 0.3;
                        rightThigh.rotation.x = Math.sin(walkTime) * 0.3;
                    }
                    
                    if (isFirstPerson) {
                        // En mode FPS, d√©placer le joueur et la cam√©ra ensemble
                        const forward = fpsCamera.getDirection(BABYLON.Axis.Z);
                        const right = fpsCamera.getDirection(BABYLON.Axis.X);
                        forward.y = 0;
                        right.y = 0;
                        forward.normalize();
                        right.normalize();
                        
                        const moveDirection = forward.scale(direction.z).add(right.scale(direction.x));
                        fpsCamera.position.addInPlace(moveDirection.scale(speed));
                        player.position.copyFrom(fpsCamera.position);
                        player.position.y = 0;
                        
                        // Limiter le mouvement √† la grille
                        player.position.x = Math.max(-0.5, Math.min(8.5, player.position.x));
                        player.position.z = Math.max(-0.5, Math.min(8.5, player.position.z));
                        fpsCamera.position.x = player.position.x;
                        fpsCamera.position.z = player.position.z;
                        
                        // Orienter le joueur dans la direction du mouvement
                        player.rotation.y = Math.atan2(moveDirection.x, moveDirection.z);
                    }
                    // En mode spectateur, les touches ne font rien (la cam√©ra est d√©j√† contr√¥l√©e par la souris)
                } else {
                    // R√©initialiser les animations quand immobile
                    if (!isFirstPerson) {
                        leftArm.rotation.x = 0;
                        rightArm.rotation.x = 0;
                        leftThigh.rotation.x = 0;
                        rightThigh.rotation.x = 0;
                    }
                }

                scene.render();
            });

            // Redimensionnement
            window.addEventListener('resize', function() {
                engine.resize();
            });
        }
    </script>
</body>
</html>
